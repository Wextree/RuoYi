# 后台手册

> 自己对于模块内容的学习与总结



## PageHelper分页配置及其封装





## Mybatis + druid 不启用自动配置并且多数据源

> 这些类主要都在ruoyi-framework模块里的config包下

### 1. 先去除SpringBoot对于dataSource的自动配置

```java
// exclude属性标明去除的自动配置类
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
// 指定要扫描的Mapper类的包的路径
@MapperScan("com.ruoyi.**.mapper")
public class RuoYiApplication {
    ......
}
```



**可以在启动类上标注扫描包的路径，也可以标注在配置类上，如下：（本项目采用配置类的方式）**

```java
@Configuration
// 表示通过aop框架暴露该代理对象,AopContext能够访问
@EnableAspectJAutoProxy(exposeProxy = true)(无关，可选，该注解具体意义见下详解)
// 指定要扫描的Mapper类的包的路径
@MapperScan("com.ruoyi.**.mapper")
public class ApplicationConfig {
}
```



### 2. 编写druid连接池的配置属性

由于我们取消了SpringBoot的对于数据库的自动配置，所以我们要自己去编写对应的属性获取。

```java
@Configuration
public class DruidProperties {
    // 获取配置文件中对应的属性值
    @Value("${spring.datasource.druid.initialSize}")
    private int initialSize;

    @Value("${spring.datasource.druid.minIdle}")
    private int minIdle;

    @Value("${spring.datasource.druid.maxActive}")
    private int maxActive;

    @Value("${spring.datasource.druid.maxWait}")
    private int maxWait;

    @Value("${spring.datasource.druid.timeBetweenEvictionRunsMillis}")
    private int timeBetweenEvictionRunsMillis;

    @Value("${spring.datasource.druid.minEvictableIdleTimeMillis}")
    private int minEvictableIdleTimeMillis;

    @Value("${spring.datasource.druid.maxEvictableIdleTimeMillis}")
    private int maxEvictableIdleTimeMillis;

    @Value("${spring.datasource.druid.validationQuery}")
    private String validationQuery;

    @Value("${spring.datasource.druid.testWhileIdle}")
    private boolean testWhileIdle;

    @Value("${spring.datasource.druid.testOnBorrow}")
    private boolean testOnBorrow;

    @Value("${spring.datasource.druid.testOnReturn}")
    private boolean testOnReturn;

	// 将Druid连接池进行属性上的配置输入，然后将输入好的连接池返回
    public DruidDataSource dataSource(DruidDataSource dataSource){
        /** 配置初始化大小、最小、最大 */
        dataSource.setInitialSize(initialSize);
        dataSource.setMaxActive(maxActive);
        dataSource.setMinIdle(minIdle);

        /** 配置获取连接等待超时的时间 */
        dataSource.setMaxWait(maxWait);

        /** 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 */
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);

        /** 配置一个连接在池中最小、最大生存的时间，单位是毫秒 */
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        dataSource.setMaxEvictableIdleTimeMillis(maxEvictableIdleTimeMillis);

        /**
         * 用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。
         */
        dataSource.setValidationQuery(validationQuery);

        /** 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 */
        dataSource.setTestWhileIdle(testWhileIdle);
        /** 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 */
        dataSource.setTestOnBorrow(testOnBorrow);
        /** 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 */
        dataSource.setTestOnReturn(testOnReturn);
        return dataSource;
    }
}
```



### 3. druid连接池配置多数据源

- **新建一个druid配置类，用于做数据源配置。**

  ```java
  @Configuration
  public class DruidConfig {
      ......
  }
  ```

- **加入主从数据库的配置：**

  ```java
  @Bean  // 加入容器中
  @ConfigurationProperties("spring.datasource.druid.master")   // 对应配置文件属性
  public DataSource masterDataSource(DruidProperties druidProperties){
      // 获取基础配置注入该数据源
      DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
      return druidProperties.dataSource(dataSource);
  }
  
  @Bean
  @ConfigurationProperties("spring.datasource.druid.slave")
  // 当"enabled"属性的值为"true"时，从数据库才生效
  @ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enabled", havingValue = "true")
  public DataSource slaveDataSource(DruidProperties druidProperties)
  {
      DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
      return druidProperties.dataSource(dataSource);
  }
  ```



### 4. 动态数据源切换

在Spring 2.0.1中引入了AbstractRoutingDataSource, 该类充当了**DataSource的路由中介**, 能有在**运行时**, 根据某种key值来**动态切换**到真正的DataSource上。

Spring2.x的版本中采用Proxy模式，就是我们在方案中实现一个虚拟的数据源，并且用它来**封装数据源选择逻辑**，这样就可以有效地将数据源选择逻辑从Client中分离出来。Client**提供选择所需的上下文**（因为这是Client所知道的），由虚拟的DataSource根据Client提供的上下文来实现数据源的选择。 

具体的实现就是，虚拟的DataSource仅需继承 **AbstractRoutingDataSource** 实现 `determineCurrentLookupKey（）`在其中封装数据源的选择逻辑

#### (1) 在配置类中加入动态数据库对应的Bean

```java
@Bean(name = "dynamicDataSource")
@Primary  // 优先考虑，优先考虑被注解的对象注入
public DynamicDataSource dataSource(DataSource masterDataSource) {
    // 建立一个key到数据源的映射
    Map<Object, Object> targetDataSources = new HashMap<>();
    // 先把主数据源加入，masterDataSource会自动匹配主数据源配置
    // 简单的枚举
    targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource);
    // 将备选数据源加入
    setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource");

    return new DynamicDataSource(masterDataSource, targetDataSources);
}

/**
 * 设置其他数据源，该函数的内容可以直接写在上面
 * 但是如果备选数据源太多，就可以设计一个函数统一加入备选源
 *
 * @param targetDataSources 备选数据源集合
 * @param sourceName 数据源名称
 * @param beanName bean名称
 */
public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName)
{
    try
    {
        // 一个获取容器内实例对象的工具类
        DataSource dataSource = SpringUtils.getBean(beanName);
        targetDataSources.put(sourceName, dataSource);
    }
    catch (Exception e)
    {
    }
}
```



#### （2）创建动态数据源

```java
public class DynamicDataSource extends AbstractRoutingDataSource
{	
    // 覆盖父类构造方法，配置默认数据源和数据映射map
    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources)
    {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey()
    {	
        // 这一步是为了解耦，把获取key的方法封装起来，用其他方式调用返回
        return DynamicDataSourceContextHolder.getDataSourceType();
    }
}
```



#### （3） 线程切换处理

```java
public class DynamicDataSourceContextHolder {
    // 日志记录
    public static final Logger log = LoggerFactory.getLogger(DynamicDataSourceContextHolder.class);

    /**
     * 使用ThreadLocal维护变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，
     *  所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
     */
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();

    /**
     * 设置数据源的变量
     */
    public static void setDataSourceType(String dsType)
    {
        log.info("切换到{}数据源", dsType);
        CONTEXT_HOLDER.set(dsType);
    }

    /**
     * 获得数据源的变量
     */
    public static String getDataSourceType()
    {
        return CONTEXT_HOLDER.get();
    }

    /**
     * 清空数据源变量
     */
    public static void clearDataSourceType()
    {
        CONTEXT_HOLDER.remove();
    }
}
```











## 其他

### @EnableAspectJAutoProxy 注解

> 参考文档：https://www.jianshu.com/p/f504afb066f9

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
    // 使用CGLIB代理
    boolean proxyTargetClass() default false;
    // 是否暴露代理对象
    boolean exposeProxy() default false;
}
```

在这个注解中引入AspectJAutoProxyRegistrar，它是ImportBeanDefinitionRegistrar接口的实现

这是一种向容器导入Bean的方式，此方式的详解和其他方式的详解请看另外一篇文章：[Spring注解开发](https://gitee.com/wextree/WexNote/blob/master/LearningNotes/Spring/Spring注解开发.md)



#### AspectJAutoProxyRegistrar 的 registerBeanDefinitions方法：

```java
public void registerBeanDefinitions(
        AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    // 注册AnnotationAwareAspectJAutoProxyCreator 
    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
    AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
    // proxyTargetClass:true强制使用CGLIB代理  
    if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
    }
    // 是否暴露代理对象 
    if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
        AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
    }
}
```

1、进入`AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary`方法会发现这个方法将一个类`AnnotationAwareAspectJAutoProxyCreator`注册到了容器中。
 2、proxyTargetClass=true则强制使用CGLIB代理，否则会**根据目标类是否实现了接口**，自动选择是JDK代理或者是CGLIB代理。
 3、有时候目标对象内部的自我调用无法实施切面中增强。exposeProxy=true会将代理对象暴露到AopContext中，此时使用AopContext.currentProxy即可。



#### AOP切入点

AnnotationAwareAspectJAutoProxyCreator类的继承关系为：

```ruby
AnnotationAwareAspectJAutoProxyCreator -> AbstractAutoProxyCreator -> SmartInstantiationAwareB -> BeanPostProcessor
```

AnnotationAwareAspectJAutoProxyCreator 是 **BeanPostProcessor**接口的实现。

实现这个接口之后会有两个方法：（由此可以看到切入的时机）

```java
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    // 在所有初始化处理之前
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization..." + beanName + "==>" + bean);
        // 返回要使用的bean对象
        return bean;
    }

    @Override
    // 在所有初始化处理之后
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization..." + beanName + "==>" + bean);
        return bean;
    }
}
```

具体的实现细节请看：[Spring注解开发](https://gitee.com/wextree/WexNote/blob/master/LearningNotes/Spring/Spring注解开发.md)



#### 代理对象生成和切面织入过程

由于深入下去源码很多很复杂，而对于这个项目我们不需要了解过多，如果有兴趣的话请移步这篇文章https://www.jianshu.com/p/f504afb066f9，这个作者分析的挺好。

简单说一下接下来会做的事情：

- 找到所有配置的切面类，也就是@AspectJ注解标注的类，或者是xml配置的通知。
- 将增强的逻辑织入对应的类中。
- 此时已经知道对应的代理方式，直接按要求生成对应的代理类。











