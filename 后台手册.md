# 后台手册

> 自己对于模块内容的学习与总结



## PageHelper分页配置及其封装

使用MyBatis的**PageHelper**插件进行分页，然后返回给前端展示。

原来只需要在前端传入对应的pageNum, pageSize，然后调用插件的函数`PageHelper.startPage(pageNum, pageSize, orderBy);`

就可以完成分页，大概如此：

```java
@RestController
public class DemoController {

    @GetMapping("/")
    public String hello(@RequestParam("pageNum") int pageNum, @RequestParam("pageSize") int pageSize){
        PageHelper.startPage(pageNum, pageSize);
        xxxDao.selectAll();  // 对应的数据库查找函数
        return "hello";
    }
}
```



但是此项目作者并没有这样写，而是把它封装的非常好，包括一些判空，还有从request获取对应的数值等，进行自定义封装到**BaseController**这个类中。

```java
@PostMapping("/list")
@ResponseBody
public TableDataInfo list(User user){
    startPage();  // 此方法配合前端完成自动分页
    List<User> list = userService.selectUserList(user);
    return getDataTable(list);
}
```



### 1. 新建一个BaseController类进行数据接收和判断

```java
/**
 * web层通用数据处理
 */
public class BaseController {
   	...

    /**
     * 设置请求分页数据
     */
    protected void startPage(){
        // PageDomain是存储着分页数据的一个类
        // TableSupport.buildPageRequest() 从request域中获取分页参数并且转换类型
        PageDomain pageDomain = TableSupport.buildPageRequest();
        Integer pageNum = pageDomain.getPageNum();
        Integer pageSize = pageDomain.getPageSize();
		
        // 简单的判空
        if (StringUtils.isNotNull(pageNum) && StringUtils.isNotNull(pageSize)){
            // 检查防止注入
            String orderBy = SqlUtils.escapeOrderBySql(pageDomain.getOrderBy());
            PageHelper.startPage(pageNum, pageSize, orderBy);
        }
    }

    ...
}
```



### 2. PageDomain 存储分页数据

```java
public class PageDomain
{
    /** 当前记录起始索引 */
    private Integer pageNum;
    /** 每页显示记录数 */
    private Integer pageSize;
    /** 排序列 */
    private String orderByColumn;
    /** 排序的方向 "desc" 或者 "asc". */
    private String isAsc;

    public String getOrderBy()
    {
        if (StringUtils.isEmpty(orderByColumn))
        {
            return "";
        }
        // 驼峰命名转下划线
        return StringUtils.toUnderScoreCase(orderByColumn) + " " + isAsc;
    }
```



### 3. 封装分页对象

```java
public class TableSupport {
    /**
     * 封装分页对象
     */
    public static PageDomain getPageDomain(){
        PageDomain pageDomain = new PageDomain();
        // public static final String PAGE_NUM = "pageNum";
        pageDomain.setPageNum(ServletUtils.getParameterToInt(Constants.PAGE_NUM));
        // public static final String PAGE_SIZE = "pageSize";
        pageDomain.setPageSize(ServletUtils.getParameterToInt(Constants.PAGE_SIZE));
        // public static final String ORDER_BY_COLUMN = "orderByColumn";
        pageDomain.setOrderByColumn(ServletUtils.getParameter(Constants.ORDER_BY_COLUMN));
        // public static final String IS_ASC = "isAsc";
        pageDomain.setIsAsc(ServletUtils.getParameter(Constants.IS_ASC));
        return pageDomain;
    }

    public static PageDomain buildPageRequest(){
        return getPageDomain();
    }
}
```

```java
/**
 * 客户端工具类
 *
 */
public class ServletUtils {
    
    // 获取RequestAttributes
    public static ServletRequestAttributes getRequestAttributes(){
        RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
        return (ServletRequestAttributes)attributes;
    }

    // 获取request
    public static HttpServletRequest getRequest(){
        return getRequestAttributes().getRequest();
    }
    
	public static Integer getParameterToInt(String name){
        // Convert是一个类型转换器
    	return Convert.toInt(getRequest().getParameter(name));
	}
    
    public static String getParameter(String name){
        return getRequest().getParameter(name);
    }
}
```



### 4. 防止注入

```java
public class SqlUtils {
    /**
     * 仅支持字母、数字、下划线、空格、逗号（支持多个字段排序）
     */
    public static String SQL_PATTERN = "[a-zA-Z0-9_\\ \\,]+";

    /**
     * 检查字符，防止注入绕过
     */
    public static String escapeOrderBySql(String value){
        if (StringUtils.isNotEmpty(value) && !isValidOrderBySql(value)){
            return StringUtils.EMPTY;
        }

        return value;
    }

    /**
     * 验证 order by 语法是否符合规范
     */
    private static boolean isValidOrderBySql(String value) {
        // 验证是否有除了字母、数字、下划线、空格、逗号之外的特殊符号
        return value.matches(SQL_PATTERN);
    }


}
```



### 常见坑点

#### 1. selectPostById莫名其妙的分页

```java
startPage();
List<User> list;
if(user != null){
    list = userService.selectUserList(user);
} else {
    list = new ArrayList<User>();
}
Post post = postService.selectPostById(1L);
return getDataTable(list);
```

原因分析：这种情况下由于user存在null的情况，就会导致`PageHelper`生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。 当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。
上面这个代码，应该写成下面这个样子才能保证安全。

```java
List<User> list;
if(user != null){
	startPage();
	list = userService.selectUserList(user);
} else {
	list = new ArrayList<User>();
}
Post post = postService.selectPostById(1L);
return getDataTable(list);
```



#### 2. 没有正常分页

```java
startPage();
Post post = postService.selectPostById(1L);
List<User> list = userService.selectUserList(user);
return getDataTable(list);
```

原因分析：只对该语句以后的第一个查询（Select）语句得到的数据进行分页。
上面这个代码，应该写成下面这个样子才能正常分页。

```java
Post post = postService.selectPostById(1L);
startPage();
List<User> list = userService.selectUserList(user);
return getDataTable(list);
```



#### 总结

就是`startPage();`一定要**紧跟**在你想要分页的查询语句的前面。







## Mybatis + druid 不启用自动配置并且多数据源

> 这些类主要都在ruoyi-framework模块里的config包下

### 1. 先去除SpringBoot对于dataSource的自动配置

```java
// exclude属性标明去除的自动配置类
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
// 指定要扫描的Mapper类的包的路径
@MapperScan("com.ruoyi.**.mapper")
public class RuoYiApplication {
    ......
}
```



**可以在启动类上标注扫描包的路径，也可以标注在配置类上，如下：（本项目采用配置类的方式）**

```java
@Configuration
// 表示通过aop框架暴露该代理对象,AopContext能够访问
@EnableAspectJAutoProxy(exposeProxy = true)(无关，可选，该注解具体意义见下详解)
// 指定要扫描的Mapper类的包的路径
@MapperScan("com.ruoyi.**.mapper")
public class ApplicationConfig {
}
```



### 2. 编写druid连接池的配置属性

由于我们取消了SpringBoot的对于数据库的自动配置，所以我们要自己去编写对应的属性获取。

```java
@Configuration
public class DruidProperties {
    // 获取配置文件中对应的属性值
    @Value("${spring.datasource.druid.initialSize}")
    private int initialSize;

    @Value("${spring.datasource.druid.minIdle}")
    private int minIdle;

    @Value("${spring.datasource.druid.maxActive}")
    private int maxActive;

    @Value("${spring.datasource.druid.maxWait}")
    private int maxWait;

    @Value("${spring.datasource.druid.timeBetweenEvictionRunsMillis}")
    private int timeBetweenEvictionRunsMillis;

    @Value("${spring.datasource.druid.minEvictableIdleTimeMillis}")
    private int minEvictableIdleTimeMillis;

    @Value("${spring.datasource.druid.maxEvictableIdleTimeMillis}")
    private int maxEvictableIdleTimeMillis;

    @Value("${spring.datasource.druid.validationQuery}")
    private String validationQuery;

    @Value("${spring.datasource.druid.testWhileIdle}")
    private boolean testWhileIdle;

    @Value("${spring.datasource.druid.testOnBorrow}")
    private boolean testOnBorrow;

    @Value("${spring.datasource.druid.testOnReturn}")
    private boolean testOnReturn;

	// 将Druid连接池进行属性上的配置输入，然后将输入好的连接池返回
    public DruidDataSource dataSource(DruidDataSource dataSource){
        /** 配置初始化大小、最小、最大 */
        dataSource.setInitialSize(initialSize);
        dataSource.setMaxActive(maxActive);
        dataSource.setMinIdle(minIdle);

        /** 配置获取连接等待超时的时间 */
        dataSource.setMaxWait(maxWait);

        /** 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 */
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);

        /** 配置一个连接在池中最小、最大生存的时间，单位是毫秒 */
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        dataSource.setMaxEvictableIdleTimeMillis(maxEvictableIdleTimeMillis);

        /**
         * 用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。
         */
        dataSource.setValidationQuery(validationQuery);

        /** 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 */
        dataSource.setTestWhileIdle(testWhileIdle);
        /** 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 */
        dataSource.setTestOnBorrow(testOnBorrow);
        /** 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 */
        dataSource.setTestOnReturn(testOnReturn);
        return dataSource;
    }
}
```



### 3. druid连接池配置多数据源

- **新建一个druid配置类，用于做数据源配置。**

  ```java
  @Configuration
  public class DruidConfig {
      ......
  }
  ```

- **加入主从数据库的配置：**

  ```java
  @Bean  // 加入容器中
  @ConfigurationProperties("spring.datasource.druid.master")   // 对应配置文件属性
  public DataSource masterDataSource(DruidProperties druidProperties){
      // 获取基础配置注入该数据源
      DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
      return druidProperties.dataSource(dataSource);
  }
  
  @Bean
  @ConfigurationProperties("spring.datasource.druid.slave")
  // 当"enabled"属性的值为"true"时，从数据库才生效
  @ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enabled", havingValue = "true")
  public DataSource slaveDataSource(DruidProperties druidProperties)
  {
      DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
      return druidProperties.dataSource(dataSource);
  }
  ```



### 4. 动态数据源切换

在Spring 2.0.1中引入了AbstractRoutingDataSource, 该类充当了**DataSource的路由中介**, 能有在**运行时**, 根据某种key值来**动态切换**到真正的DataSource上。

Spring2.x的版本中采用Proxy模式，就是我们在方案中实现一个虚拟的数据源，并且用它来**封装数据源选择逻辑**，这样就可以有效地将数据源选择逻辑从Client中分离出来。Client**提供选择所需的上下文**（因为这是Client所知道的），由虚拟的DataSource根据Client提供的上下文来实现数据源的选择。 

具体的实现就是，虚拟的DataSource仅需继承 **AbstractRoutingDataSource** 实现 `determineCurrentLookupKey（）`在其中封装数据源的选择逻辑

#### (1) 在配置类中加入动态数据库对应的Bean

```java
@Bean(name = "dynamicDataSource")
@Primary  // 优先考虑，优先考虑被注解的对象注入
public DynamicDataSource dataSource(DataSource masterDataSource) {
    // 建立一个key到数据源的映射
    Map<Object, Object> targetDataSources = new HashMap<>();
    // 先把主数据源加入，masterDataSource会自动匹配主数据源配置
    // 简单的枚举
    targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource);
    // 将备选数据源加入
    setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource");

    return new DynamicDataSource(masterDataSource, targetDataSources);
}

/**
 * 设置其他数据源，该函数的内容可以直接写在上面
 * 但是如果备选数据源太多，就可以设计一个函数统一加入备选源
 *
 * @param targetDataSources 备选数据源集合
 * @param sourceName 数据源名称
 * @param beanName bean名称
 */
public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName)
{
    try
    {
        // 一个获取容器内实例对象的工具类
        DataSource dataSource = SpringUtils.getBean(beanName);
        targetDataSources.put(sourceName, dataSource);
    }
    catch (Exception e)
    {
    }
}
```



#### (2) 创建动态数据源

```java
public class DynamicDataSource extends AbstractRoutingDataSource
{	
    // 覆盖父类构造方法，配置默认数据源和数据映射map
    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources)
    {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey()
    {	
        // 这一步是为了解耦，把获取key的方法封装起来，用其他方式调用返回
        return DynamicDataSourceContextHolder.getDataSourceType();
    }
}
```



#### (3) 线程切换处理

```java
public class DynamicDataSourceContextHolder {
    // 日志记录
    public static final Logger log = LoggerFactory.getLogger(DynamicDataSourceContextHolder.class);

    /**
     * 使用ThreadLocal维护变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，
     *  所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
     */
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();

    /**
     * 设置数据源的变量
     */
    public static void setDataSourceType(String dsType)
    {
        log.info("切换到{}数据源", dsType);
        CONTEXT_HOLDER.set(dsType);
    }

    /**
     * 获得数据源的变量
     */
    public static String getDataSourceType()
    {
        return CONTEXT_HOLDER.get();
    }

    /**
     * 清空数据源变量
     */
    public static void clearDataSourceType()
    {
        CONTEXT_HOLDER.remove();
    }
}
```











## 其他

### @EnableAspectJAutoProxy 注解

> 参考文档：https://www.jianshu.com/p/f504afb066f9

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
    // 使用CGLIB代理
    boolean proxyTargetClass() default false;
    // 是否暴露代理对象
    boolean exposeProxy() default false;
}
```

在这个注解中引入AspectJAutoProxyRegistrar，它是ImportBeanDefinitionRegistrar接口的实现

这是一种向容器导入Bean的方式，此方式的详解和其他方式的详解请看另外一篇文章：[Spring注解开发](https://gitee.com/wextree/WexNote/blob/master/LearningNotes/Spring/Spring注解开发.md)



#### AspectJAutoProxyRegistrar 的 registerBeanDefinitions方法：

```java
public void registerBeanDefinitions(
        AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    // 注册AnnotationAwareAspectJAutoProxyCreator 
    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
    AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
    // proxyTargetClass:true强制使用CGLIB代理  
    if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
    }
    // 是否暴露代理对象 
    if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
        AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
    }
}
```

1、进入`AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary`方法会发现这个方法将一个类`AnnotationAwareAspectJAutoProxyCreator`注册到了容器中。
 2、proxyTargetClass=true则强制使用CGLIB代理，否则会**根据目标类是否实现了接口**，自动选择是JDK代理或者是CGLIB代理。
 3、有时候目标对象内部的自我调用无法实施切面中增强。exposeProxy=true会将代理对象暴露到AopContext中，此时使用AopContext.currentProxy即可。



#### AOP切入点

AnnotationAwareAspectJAutoProxyCreator类的继承关系为：

```ruby
AnnotationAwareAspectJAutoProxyCreator -> AbstractAutoProxyCreator -> SmartInstantiationAwareB -> BeanPostProcessor
```

AnnotationAwareAspectJAutoProxyCreator 是 **BeanPostProcessor**接口的实现。

实现这个接口之后会有两个方法：（由此可以看到切入的时机）

```java
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    // 在所有初始化处理之前
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization..." + beanName + "==>" + bean);
        // 返回要使用的bean对象
        return bean;
    }

    @Override
    // 在所有初始化处理之后
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization..." + beanName + "==>" + bean);
        return bean;
    }
}
```

具体的实现细节请看：[Spring注解开发](https://gitee.com/wextree/WexNote/blob/master/LearningNotes/Spring/Spring注解开发.md)



#### 代理对象生成和切面织入过程

由于深入下去源码很多很复杂，而对于这个项目我们不需要了解过多，如果有兴趣的话请移步这篇文章https://www.jianshu.com/p/f504afb066f9，这个作者分析的挺好。

简单说一下接下来会做的事情：

- 找到所有配置的切面类，也就是@AspectJ注解标注的类，或者是xml配置的通知。
- 将增强的逻辑织入对应的类中。
- 此时已经知道对应的代理方式，直接按要求生成对应的代理类。



### @InitBinder

`@InitBinder`用于在`@Controller`中标注于方法，表示为当前控制器注册一个属性编辑器或者其他，只对当前的Controller有效。



#### 用途一：类型转换

```java
@RequestMapping("test")
@Controller
public class TestController {

    @InitBinder
    public     void InitBinder(WebDataBinder binder){
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        CustomDateEditor dateEditor = new CustomDateEditor(df, true);
        binder.registerCustomEditor(Date.class,dateEditor);
    }

    @RequestMapping(value="/param",method=RequestMethod.GET)
    @ResponseBody
    public Map<String,Object> getFormatData(Date date) throws ParseException{
        Map<String,Object> map = new HashMap<String, Object>();
        map.put("name", "zhangsan");
        map.put("age", 22);
        map.put("date",date);
        return map;
    }
}
```



#### 用途二： 参数绑定

```jsp
<form action="/testBean" method="post">
    name: <input type="text" name="u.name"> <br>
    age: <input type="text" name="u.age"> <br>
    name: <input type="text" name="s.name"> <br>
    age: <input type="text" name="s.age"> <br>
    <input type="submit">
</form>
```

```java
    @InitBinder("user")
    public void init1(WebDataBinder binder) {
        binder.setFieldDefaultPrefix("u.");
    }

    @InitBinder("stu")
    public void init2(WebDataBinder binder) {
        binder.setFieldDefaultPrefix("s.");
    }

    @RequestMapping("/testBean")
    public ModelAndView testBean(User user, @ModelAttribute("stu") Student stu) {
        System.out.println(stu);
        System.out.println(user);
        String viewName = "success";
        ModelAndView modelAndView = new ModelAndView(viewName);
        modelAndView.addObject("user", user);
        modelAndView.addObject("student", stu);
        return modelAndView;

    }
```

> `@InitBinder("user")`括号内的参数为类的首字母小写(默认命名规则),也可以用`@ModelAttribute("stu")`做限定.